# Document 4: Development Guidelines

These guidelines are mandatory for all development to ensure code quality, consistency, and maintainability.

## 1. Coding Style & Quality

*   **PEP 8:** All Python code must adhere to the [PEP 8](https://www.python.org/dev/peps/pep-0008/) style guide.
*   **Formatting:** We use `black` for automated code formatting. All code must be formatted before committing.
*   **Linting:** We use `ruff` to catch common errors and style issues. Code must be free of linting errors.

## 2. Type Annotations

*   **100% Type Hinted:** All functions, methods, and variables must have explicit type annotations in accordance with [PEP 484](https://www.python.org/dev/peps/pep-0484/).
*   **Static Analysis:** We use `mypy` to enforce type correctness. Your code must pass `mypy` checks without errors.

## 3. Docstrings and Comments

*   **Google Style Docstrings:** All modules, classes, functions, and methods must have comprehensive docstrings following the [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings).
*   **Clarity Over Cuteness:** Write clear, concise comments where the code's purpose is not immediately obvious. Avoid unnecessary or distracting comments.

## 4. Language and Localization

*   **English Only:** All code, including comments, docstrings, variable names, and log messages, **must be written in English**.
*   **Rationale:** This is a universal standard in software development that ensures the project is accessible to the widest possible audience of developers and contributors.
*   **Documentation:** User-facing documentation can be bilingual, residing in the `docs/en/` and `docs/cs/` directories.

## 5. Configuration and Secrets Management

To ensure security, centralization, and ease of management, the following rule applies:

**Plugins must never manage their own configuration or read configuration files/environment variables directly.**

*   **Dependency Injection Principle:**
    1.  All configuration (API keys, paths, feature flags) is defined **only** in a central configuration file (e.g., `config/settings.yaml`).
    2.  The **`PluginManager`** is the sole component responsible for reading this configuration.
    3.  During plugin initialization (within its `setup()` method), the `PluginManager` will pass all the necessary configuration values that the specific plugin requires.
    4.  Therefore, the plugin receives its settings "from the outside" and never concerns itself with where they came from.

*   **Advantages:**
    *   **Security:** API keys and other sensitive data are centralized, not scattered throughout the plugin codebase.
    *   **Centralization:** When a parameter needs to be changed, it is done in a single location.
    *   **Testability:** During testing, we can easily inject a mock configuration into a plugin without needing to manipulate files or environment variables.

## 6. Documentation Maintenance

**Rule:** Code is not complete until the documentation is updated.

*   **Mandatory Updates:** Every code change that introduces a new feature, alters existing behavior, or changes the setup process **must** be accompanied by a corresponding update to the documentation.
*   **Responsibility:** The developer making the code change is responsible for updating all relevant documents.
*   **Bilingual Sync:** All documentation must be kept in sync between the English (`docs/en/`) and Czech (`docs/cs/`) versions. The English version is considered the source of truth.

## 7. Multi-Step Plan Execution

The Kernel is capable of executing complex, multi-step plans generated by the `CognitivePlanner`. This functionality relies on two key architectural patterns:

### 7.1. Result Chaining

A step in a plan can use the output of a previous step as one of its arguments. This is accomplished using a specific placeholder syntax.

*   **Syntax:** `"$result.step_N"`
*   **Example:** If Step 1 is `list_plugins()` and Step 2 is `write_file()`, the plan can instruct the system to write the output of the first step to a file like this:
    ```json
    "arguments": {
        "path": "output.txt",
        "content": "$result.step_1"
    }
    ```
*   The Kernel is responsible for parsing this syntax, retrieving the stored output from the specified step, and substituting it into the arguments before the tool is executed.

### 7.2. History-Aware Context Propagation

For a multi-step plan to succeed, later steps (especially those involving an LLM) must have access to the results and actions of earlier steps. The Kernel ensures this via **History-Aware Context Propagation**.

*   **Mechanism:** Before executing *each* step in a plan, the Kernel creates a new, temporary `SharedContext` object for that specific step.
*   **Enriched History:** The `history` attribute of this new context is a complete record of the session up to that point. It contains:
    1.  The original user request.
    2.  "Assistant" messages explicitly stating the output of *all previously executed steps* in the current plan.
*   **Context Injection:** This enriched, history-aware context is then injected into the tool call for the current step (if the tool's method signature requires a `context` argument).
*   **Importance:** This ensures that every tool in the chain has the full context necessary to perform its function, enabling the agent to reason about and execute complex, sequential tasks.

## 8. Plugin Development Best Practices

To ensure plugins are robust, maintainable, and integrate seamlessly with the Kernel, the following best practices are mandatory.

### 8.1. Context-Aware Logging

**Rule:** All logging operations within a plugin's methods **must** use the logger provided in the `SharedContext` object. Do not use a module-level logger (`logging.getLogger(__name__)`).

*   **Mechanism:** The Kernel injects a session-specific logger into the `Shared-Context` for every operation. Using `context.logger` ensures that all log messages are automatically tagged with the correct `session_id`, which is critical for debugging and tracing multi-step tasks.

*   **Correct Example:**
    ```python
    def my_tool_method(self, context: SharedContext, ...):
        context.logger.info("Executing my method.")
    ```

*   **Incorrect Example:**
    ```python
    import logging
    logger = logging.getLogger(__name__)

    def my_tool_method(self, ...):
        # This log will be missing the session_id!
        logger.info("Executing my method.")
    ```

### 8.2. Explicit Tool Design for AI

**Principle:** When designing tools for the AI, always prioritize maximum explicitness. The AI is only as good as the information it is given.

*   **Clear Naming:** Method names should be descriptive and unambiguous (e.g., `execute_command` is better than `run`).
*   **Detailed Descriptions:** The `description` field for a tool's function in `get_tool_definitions` should clearly and concisely explain what the tool does, what its parameters are for, and what it returns.
*   **Assume Nothing:** Do not assume the LLM "knows" what a function does based on its name. The description is its primary source of information. A well-designed tool requires minimal "guessing" from the LLM, leading to more reliable and predictable plans.
