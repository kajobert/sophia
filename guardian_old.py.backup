#!/usr/bin/env python3
"""
Simple guardian watchdog for Sophia.

Starts the main supervisor (`scripts/autonomous_main.py`) and restarts it if it crashes.
Writes crash logs to `logs/guardian.log` and backs up the last crash output.

Run this script separately (it will daemonize the supervised process).
"""
import subprocess
import time
import shutil
from datetime import datetime
from pathlib import Path

ROOT = Path(__file__).resolve().parent
LOG_DIR = ROOT / "logs"
LOG_DIR.mkdir(parents=True, exist_ok=True)

SUPERVISOR_CMD = [str(ROOT / ".venv" / "bin" / "python"), str(ROOT / "scripts" / "autonomous_main.py")]

MAX_CRASHES = 5
CRASH_WINDOW = 600  # seconds


def rotate_crash_log(content: str):
    ts = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    out = LOG_DIR / f"last_crash_{ts}.log"
    out.write_text(content, encoding="utf-8")
    return out


def run_guardian():
    crash_times = []
    while True:
        start_ts = datetime.utcnow()
        log_path = LOG_DIR / "supervisor_child.log"
        with open(log_path, "wb") as out:
            proc = subprocess.Popen(SUPERVISOR_CMD, stdout=out, stderr=subprocess.STDOUT)
            pid = proc.pid
            print(f"[guardian] Started supervisor pid={pid}")
            rc = proc.wait()

        end_ts = datetime.utcnow()
        duration = (end_ts - start_ts).total_seconds()

        # Read crash output
        try:
            content = log_path.read_text(encoding="utf-8")
        except Exception:
            content = "(failed to read child log)"

        rotate_crash_log(content)

        # Record crash time and decide whether to back off
        now = time.time()
        crash_times = [t for t in crash_times if now - t < CRASH_WINDOW]
        crash_times.append(now)

        if len(crash_times) >= MAX_CRASHES:
            # Too many crashes in short window â€” escalate and sleep longer
            print(f"[guardian] Supervisor crashed {len(crash_times)} times within {CRASH_WINDOW}s. Backing off.")
            time.sleep(60)
        else:
            # Short backoff proportional to number of recent crashes
            backoff = min(30, 2 ** max(1, len(crash_times)))
            print(f"[guardian] Supervisor exited with rc={rc}. Restarting in {backoff}s...")
            time.sleep(backoff)


if __name__ == "__main__":
    run_guardian()
