<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sophia Codebase Map</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #eee; background-color: #121212; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background-color: #1e1e1e; border-radius: 8px; padding: 20px; }
        h1, h2 { color: #bb86fc; border-bottom: 2px solid #373737; padding-bottom: 10px; }
        .component { margin-bottom: 20px; padding: 15px; background-color: #2a2a2a; border-radius: 5px; }
        .mermaid { text-align: center; background-color: #252526; padding: 20px; border-radius: 5px; margin-top: 20px; }
        pre { background-color: #252526; padding: 10px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; }
        code { font-family: "Fira Code", "Courier New", monospace; }
        .file-link { color: #03dac6; text-decoration: none; font-weight: bold; }
        .file-link:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container" id="map-container">
        <div style="padding: 15px; background-color: #444; border-radius: 5px; margin-bottom: 20px; border: 1px solid #bb86fc;">
            <h2 style="margin-top: 0;">How to View This Map</h2>
            <p>This interactive map uses JavaScript libraries that may not load correctly when you open this file directly from your computer.</p>
            <p>For the best experience, please serve this file using a simple local web server. If you have Python installed, you can do this easily:</p>
            <ol>
                <li>Open a terminal in the <code>analysis/interactive_map/</code> directory.</li>
                <li>Run the following command: <code>python3 -m http.server 8080</code></li>
                <li>Open your web browser and navigate to: <a href="http://localhost:8080" style="color: #03dac6;">http://localhost:8080</a></li>
            </ol>
        </div>
        <h1>Sophia Codebase Map</h1>
    </div>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: false, theme: 'dark' });

        const data = {
          "project_name": "Sophia",
          "vision": "To create an Artificial Mindful Intelligence (AMI) capable of learning, self-improvement, and potentially consciousness, inspired by human cognitive architecture.",
          "architecture_overview": {
            "type": "Event-Driven Plugin-Based Architecture",
            "summary": "Sophia's core is a non-blocking, event-driven kernel that orchestrates a collection of dynamically loaded plugins. Communication is handled by an event bus, and tasks are executed concurrently by a worker pool. This design promotes modularity, scalability, and proactivity.",
            "key_components": ["Kernel", "PluginManager", "EventBus", "TaskQueue"]
          },
          "components": {
            "core": {
              "type": "Core Infrastructure",
              "summary": "The foundational components that manage the application's lifecycle, communication, and execution.",
              "files": {
                "kernel.py": {
                  "summary": "The heart of the application. Manages the 'consciousness_loop', initializes all plugins, and handles the main application state. Supports both legacy blocking and modern event-driven modes.",
                  "interactions": {
                    "uses": ["PluginManager", "EventBus", "TaskQueue", "EventDrivenLoop"],
                    "manages": ["All Plugins"]
                  }
                },
                "plugin_manager.py": {
                  "summary": "Dynamically discovers, loads, and registers all plugins from the 'plugins/' directory. Categorizes plugins by type for easy access.",
                  "interactions": {
                    "used_by": ["Kernel"],
                    "loads": ["All Plugins"]
                  }
                },
                "event_bus.py": {
                  "summary": "A priority-based, asynchronous publish-subscribe system. It allows decoupled communication between all components of the application.",
                  "interactions": {
                    "used_by": ["Kernel", "TaskQueue", "EventDrivenLoop", "All Plugins that subscribe to events"]
                  }
                },
                "task_queue.py": {
                  "summary": "A priority-based task queue with a worker pool for concurrent execution of asynchronous tasks. Manages task dependencies, retries, and timeouts.",
                  "interactions": {
                    "uses": ["EventBus (to publish task status)"],
                    "used_by": ["EventDrivenLoop"]
                  }
                },
                "event_loop.py": {
                  "summary": "The implementation of the main 'consciousness_loop' for the event-driven mode. Subscribes to key events like USER_INPUT and orchestrates the processing pipeline by calling kernel methods and managing autonomous tasks.",
                  "interactions": {
                    "uses": ["EventBus", "TaskQueue", "Kernel"],
                    "handles_events_from": ["interface_webui", "interface_terminal"]
                  }
                }
              }
            },
            "plugins": {
              "type": "Modular Capabilities",
              "summary": "Self-contained units of functionality that adhere to the BasePlugin contract. They are categorized by type.",
              "base_contract": "plugins/base_plugin.py",
              "categories": {
                "MEMORY": {
                  "summary": "Plugins responsible for short-term and long-term data persistence.",
                  "files": {
                    "memory_sqlite.py": {
                      "summary": "Provides structured, relational memory. Manages three key tables: 'conversation_history' (short-term dialogue), 'operation_tracking' (metadata for self-reflection), and 'hypotheses' (database for the self-improvement loop).",
                      "interactions": {
                        "used_by": ["cognitive_memory_consolidator", "cognitive_task_router", "interface_webui (for dashboard)"]
                      }
                    },
                    "memory_chroma.py": {
                      "summary": "Provides long-term, semantic memory using the ChromaDB vector database. Stores knowledge as text embeddings and allows for searching by meaning, not just keywords.",
                      "interactions": {
                        "used_by": ["cognitive_memory_consolidator"]
                      }
                    }
                  }
                },
                "COGNITIVE": {
                  "summary": "The 'brain' of Sophia. These plugins handle high-level reasoning, planning, and learning.",
                  "files": {
                    "cognitive_task_router.py": {
                      "summary": "Acts as a strategic dispatcher and financial controller. Classifies user tasks, selects the most cost-effective LLM, and enforces monthly/daily budget limits by automatically switching to offline mode if necessary.",
                      "interactions": {
                        "uses": ["tool_llm (for classification)", "memory_sqlite (for budget tracking)"],
                        "called_by": ["Kernel"],
                        "configures": ["cognitive_planner (by setting model in context)"]
                      }
                    },
                    "cognitive_planner.py": {
                      "summary": "Generates a step-by-step plan to fulfill a user request. It dynamically creates a prompt with available tools, uses an LLM to generate the plan as a JSON object, and includes robust logic for parsing and repairing the LLM's output.",
                      "interactions": {
                        "uses": ["tool_llm", "tool_local_llm"],
                        "called_by": ["Kernel"]
                      }
                    },
                    "cognitive_memory_consolidator.py": {
                      "summary": "Implements the 'dreaming' process. Triggered during inactivity, it analyzes short-term memories (operations and conversations) from SQLite and consolidates important information into the long-term semantic memory (ChromaDB).",
                      "interactions": {
                        "uses": ["memory_sqlite (read)", "memory_chroma (write)"],
                        "triggered_by": ["DREAM_TRIGGER event from core_sleep_scheduler"]
                      }
                    }
                  }
                },
                "INTERFACE": {
                  "summary": "Plugins that provide interfaces for user interaction.",
                  "files": {
                    "interface_terminal.py": {
                      "summary": "Provides a command-line interface. Implements both blocking (legacy) and non-blocking (event-driven) input handling. In non-blocking mode, it publishes a USER_INPUT event to the EventBus.",
                      "interactions": {
                        "publishes_to": ["EventBus"]
                      }
                    },
                    "interface_webui.py": {
                      "summary": "Provides a rich web interface and dashboard using FastAPI and WebSockets. Handles user chat and exposes a comprehensive API to monitor and control Sophia's internal state (tasks, budget, self-improvement, etc.).",
                      "interactions": {
                        "publishes_to": ["EventBus"],
                        "reads_from": ["memory_sqlite (for dashboard stats)"],
                        "interacts_with": ["cognitive_task_router (for budget info)"]
                      }
                    }
                  }
                },
                "TOOL": {
                  "summary": "Plugins that provide specific, concrete skills and capabilities that can be used in a plan.",
                  "files": {
                    "tool_llm.py": {
                      "summary": "Provides access to cloud-based LLMs through the 'litellm' abstraction layer. Handles dynamic model selection, function calling, and cost/token tracking.",
                      "interactions": {
                        "used_by": ["All Cognitive Plugins"]
                      }
                    },
                    "tool_local_llm.py": {
                      "summary": "Provides access to locally-running LLMs, primarily via Ollama. Supports function calling and serves as a cost-free/offline alternative to tool_llm.",
                      "interactions": {
                        "used_by": ["All Cognitive Plugins (in offline mode)"]
                      }
                    },
                    "tool_file_system.py": {
                      "summary": "Provides tools for reading, writing, and listing files on the local filesystem.",
                      "interactions": {}
                    },
                    "tool_git.py": {
                      "summary": "Provides tools for interacting with Git repositories (e.g., clone, status, diff).",
                      "interactions": {}
                    },
                    "tool_web_search.py": {
                      "summary": "Provides tools for searching the web, likely using an API like Tavily.",
                      "interactions": {}
                    },
                    "tool_code_workspace.py": {
                        "summary": "Provides tools for managing and editing code within a designated workspace.",
                        "interactions": {}
                    }
                  }
                }
              }
            }
          }
        };

        async function renderMap() {
            const container = document.getElementById('map-container');

            // Project Info
            const projectInfo = document.createElement('div');
            projectInfo.className = 'component';
            projectInfo.innerHTML = `<h2>${data.project_name}</h2><p><strong>Vision:</strong> ${data.vision}</p>`;
            container.appendChild(projectInfo);

            // Architecture Overview
            const archOverview = document.createElement('div');
            archOverview.className = 'component';
            archOverview.innerHTML = `
                <h2>Architecture Overview</h2>
                <p><strong>Type:</strong> ${data.architecture_overview.type}</p>
                <p>${data.architecture_overview.summary}</p>
                <div class="mermaid" id="arch-diagram"></div>
            `;
            container.appendChild(archOverview);

            const archGraph = \`
                graph TD
                    A[Kernel] --> B(PluginManager)
                    A --> C{EventBus}
                    A --> D[TaskQueue]
                    A --> E(EventDrivenLoop)
                    subgraph Plugins
                        direction LR
                        P1[Memory]
                        P2[Cognitive]
                        P3[Interface]
                        P4[Tool]
                    end
                    B --> Plugins
                    C <--> Plugins
                    E --> C
            \`;

            const { svg: archSvg } = await mermaid.render('arch-diagram-svg', archGraph);
            document.getElementById('arch-diagram').innerHTML = archSvg;

            // Components
            for (const [compName, compData] of Object.entries(data.components)) {
                const compEl = document.createElement('div');
                compEl.className = 'component';
                compEl.innerHTML = \`<h2>Component: ${compName}</h2><p>${compData.summary}</p>\`;

                for (const [fileName, fileData] of Object.entries(compData.files)) {
                    const fileEl = document.createElement('div');
                    fileEl.innerHTML = \`
                        <h3><a class="file-link" href="#">${fileName}</a></h3>
                        <p>${fileData.summary}</p>
                    \`;
                    compEl.appendChild(fileEl);
                }
                if (compData.categories) {
                    for (const [catName, catData] of Object.entries(compData.categories)) {
                         const catEl = document.createElement('div');
                         catEl.innerHTML = \`<h3>Category: ${catName}</h3><p>${catData.summary}</p>\`;
                         for (const [fileName, fileData] of Object.entries(catData.files)) {
                            const fileEl = document.createElement('div');
                            fileEl.innerHTML = \`
                                <h4><a class="file-link" href="#">${fileName}</a></h4>
                                <p>${fileData.summary}</p>
                            \`;
                            catEl.appendChild(fileEl);
                        }
                         compEl.appendChild(catEl);
                    }
                }
                container.appendChild(compEl);
            }
        }

        renderMap();
    </script>
</body>
</html>
